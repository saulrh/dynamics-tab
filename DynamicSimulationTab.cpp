/*
 * Copyright (c) 2012, Georgia Tech Research Corporation
 * All rights reserved.
 *
 * Humanoid Robotics Lab      Georgia Institute of Technology
 * Director: Mike Stilman     http://www.golems.org
 */

#include <wx/wx.h>
#include <GUI/Viewer.h>
#include <GUI/GUI.h>
#include <GUI/GRIPSlider.h>
#include <GUI/GRIPFrame.h>
#include <Tabs/GRIPTab.h>

#include <iostream>

#include <robotics/World.h>

#include <Tabs/AllTabs.h>
#include <GRIPApp.h>

#include "DynamicSimulationTab.hpp"

/////////////////////////////////////////////////////////////////////////////////////////////
//#########################################################################################//
//# wx events stuff                                                                       #//
//#########################################################################################//
/////////////////////////////////////////////////////////////////////////////////////////////

// Control IDs (used for event handling - be sure to start with a non-conflicted id)
enum DynamicSimulationTabEvents {
    button_RunSim = 8345, // just to be safe
    button_RunFrame,
    button_StopSim,
    button_ClearHistory,
    button_SaveState,
    button_LoadState,
    button_LoadWorkingState,
    button_DeleteState,
    listbox_SavedStates
};

//Add a handler for any events that can be generated by the widgets you add here (sliders, radio, checkbox, etc)
BEGIN_EVENT_TABLE(DynamicSimulationTab, wxPanel)
EVT_COMMAND(wxID_ANY, wxEVT_GRIP_SLIDER_CHANGE, DynamicSimulationTab::OnSlider)
EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_RADIOBOX_SELECTED, DynamicSimulationTab::OnRadio)
EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_BUTTON_CLICKED, DynamicSimulationTab::OnButton)
EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_CHECKBOX_CLICKED, DynamicSimulationTab::OnCheckBox)
EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_LISTBOX_SELECTED, DynamicSimulationTab::OnListBox)
END_EVENT_TABLE()

// Class constructor for the tab: Each tab will be a subclass of RSTTab
IMPLEMENT_DYNAMIC_CLASS(DynamicSimulationTab, GRIPTab)

/////////////////////////////////////////////////////////////////////////////////////////////
//#########################################################################################//
//# simulation timer class                                                                #//
//#########################################################################################//
/////////////////////////////////////////////////////////////////////////////////////////////

class SimulationTimer : public wxTimer
{
public:
    DynamicSimulationTab* simtab;
    SimulationTimer(DynamicSimulationTab* tab);
    void Notify();
    void Start();
};

/////////////////////////////////////////////////////////////////////////////////////////////
//#########################################################################################//
//# DynamicSimulationTab constructor                                                      #//
//#########################################################################################//
/////////////////////////////////////////////////////////////////////////////////////////////

/**
 * @function RipTabPlanner
 * @brief Constructor
 */
DynamicSimulationTab::DynamicSimulationTab( wxWindow *parent, const wxWindowID id,
                                            const wxPoint& pos, const wxSize& size, long style) :
GRIPTab(parent, id, pos, size, style)
{
    sizerFull = new wxBoxSizer( wxHORIZONTAL );

    wxStaticBox* tabBox = new wxStaticBox(this, -1, wxT("Dynamics"));
    wxStaticBoxSizer* tabBoxSizer = new wxStaticBoxSizer(tabBox, wxHORIZONTAL);
    wxBoxSizer* simulationControlSizer = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* stateSizer = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* stateControlSizer = new wxBoxSizer(wxVERTICAL);
    
    simulationControlSizer->Add(new wxButton(this, button_RunSim, wxT("Start Simulation")),
                                0,     // do not resize to fit proportions vertically
                                wxALL, // border all around
                                1);    // border width is 1 so buttons are close together
    simulationControlSizer->Add(new wxButton(this, button_StopSim, wxT("Stop Simulation")),
                                0,     // do not resize to fit proportions vertically
                                wxALL, // border all around
                                1);    // border width is 1 so buttons are close together
    simulationControlSizer->Add(new wxButton(this, button_RunFrame, wxT("Simulate One Frame")),
                                0,     // do not resize to fit proportions vertically
                                wxALL, // border all around
                                1);    // border width is 1 so buttons are close together
    simulationControlSizer->Add(new wxButton(this, button_ClearHistory, wxT("Clear History")),
                                0,     // do not resize to fit proportions vertically
                                wxALL, // border all around
                                1);    // border width is 1 so buttons are close together

    stateControlSizer->Add(new wxButton(this, button_SaveState, wxT("Save State")),
                           0,     // do not resize to fit proportions vertically
                           wxALL, // border all around
                           1);    // border width is 1 so buttons are close together
    stateControlSizer->Add(new wxButton(this, button_LoadState, wxT("Load Selected State")),
                           0,     // do not resize to fit proportions vertically
                           wxALL, // border all around
                           1);    // border width is 1 so buttons are close together
    stateControlSizer->Add(new wxButton(this, button_LoadWorkingState, wxT("Load Working State")),
                           0,     // do not resize to fit proportions vertically
                           wxALL, // border all around
                           1);    // border width is 1 so buttons are close together
    stateControlSizer->Add(new wxButton(this, button_DeleteState, wxT("Delete Selected State")),
                           0,     // do not resize to fit proportions vertically
                           wxALL, // border all around
                           1);    // border width is 1 so buttons are close together
    
    stateSizer->Add(stateControlSizer,
                    1,                          // take up 1/4 of stateSizer
                    wxEXPAND | wxALIGN_CENTER,  // expand and center
                    0);                         // no border
    stateSizer->Add(new wxListBox(this, listbox_SavedStates),
                    3,                                   // take up 3/4 of stateSizer
                    wxEXPAND | wxALIGN_CENTER | wxALL,   // borders all over, expand to fit
                    1);                                  // 1-pixel border
    
    tabBoxSizer->Add(simulationControlSizer,
                     1,         // take up 1/8 of the tab
                     wxEXPAND | wxALIGN_CENTER | wxALL,
                     1);
    tabBoxSizer->Add(stateSizer,
                     7,         // take up 7/8 of the tab
                     wxEXPAND | wxALIGN_CENTER | wxALL,
                     1);

    sizerFull->Add(tabBoxSizer, 1, wxEXPAND | wxALL, 6);

    SetSizer(sizerFull);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//#########################################################################################//
//# DynamicSimulationTab event handlers                                                   #//
//#########################################################################################//
/////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////
// radiobuttons

/**
 * @function OnRadio
 * @brief Handle Radio toggle
 */
void DynamicSimulationTab::OnRadio(wxCommandEvent &evt)
{
    int sel = evt.GetSelection();
}

////////////////////////////////////////////////////////////////
// normal buttons
////////////////////////////////////////////////////////////////

/**
 * @function OnButton
 * @brief Handle Button Events
 */
void DynamicSimulationTab::OnButton(wxCommandEvent &evt) {
  
    int button_num = evt.GetId();
  
    switch (button_num)
    {
    case button_RunSim:         /** Start Simulating */
        if ( mWorld == NULL ) {
            std::cout << "(!) Must have a world loaded to simulate (!)" << std::endl;
            break;
        }
        std::cout << "(I) Simulating." << std::endl;
    case button_StopSim:        /** Stop Simulating */
        if ( mWorld == NULL ) {
            std::cout << "(!) Must have a world loaded to simulate (!)" << std::endl;
            break;
        }
        std::cout << "(I) Stopping simulation." << std::endl;
        break;
    case button_RunFrame:         /** Simulate one step */
        if ( mWorld == NULL ) {
            std::cout << "(!) Must have a world loaded to simulate (!)" << std::endl;
            break;
        }
        std::cout << "(I) Single-stepping." << std::endl;
    }
}

////////////////////////////////////////////////////////////////
// checkboxes
////////////////////////////////////////////////////////////////

/**
 * @function OnCheckBox
 * @brief Handle CheckBox Events
 */ 
void DynamicSimulationTab::OnCheckBox( wxCommandEvent &evt ) {
    int checkbox_num = evt.GetId();
    bool checkbox_val = (bool)evt.GetSelection();
  
    switch (checkbox_num)
    {
    // case checkbox_beGreedy:
    //     break;
    }
}

////////////////////////////////////////////////////////////////
// listbox item selected
////////////////////////////////////////////////////////////////

/**
 * @function OnListBox
 * @brief Handle selection of listbox items
 */
void DynamicSimulationTab::OnListBox(wxCommandEvent &evt) {
}

////////////////////////////////////////////////////////////////
// slider changed
////////////////////////////////////////////////////////////////

/**
 * @function OnSlider
 * @brief Handle slider changes
 */
void DynamicSimulationTab::OnSlider(wxCommandEvent &evt) {
    int slnum = evt.GetId();
    double pos = *(double*) evt.GetClientData();
  
    switch (slnum) {
    // case slider_Time:
    //     break;
    default:
        break;
    }

    // if (frame != NULL)
    //     frame->SetStatusText(wxString(numBuf, wxConvUTF8));
}

/////////////////////////////////////////////////////////////////////////////////////////////
//#########################################################################################//
//# simulation timer event handlers                                                       #//
//#########################################################################################//
/////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////
//#########################################################################################//
//# helper functions                                                                      #//
//#########################################################################################//
/////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// simulate one tick forward
////////////////////////////////////////////////////////////////

void DynamicSimulationTab::SimulateFrame()
{
}

////////////////////////////////////////////////////////////////
// timeline population
////////////////////////////////////////////////////////////////

/**
 * @function PopulateTimeline
 * @brief Copies the simulation history into the timeline for easy review
 */
void DynamicSimulationTab::PopulateTimeline()
{
    // TODO: get simulation_dt, calculate t
    int numsteps = mSimHistory.size();
    double simulation_dt = 0;
    double t = numsteps * simulation_dt;

    cout << "-->(+) Populating Timeline - Increment: " << simulation_dt << " Total time: " << t << " Steps: " << numsteps << endl;

    frame->InitTimer(string("Simulation_History"), simulation_dt);
    for( std::vector<Eigen::VectorXd>::iterator it = mSimHistory.begin(); it != mSimHistory.end(); it++)
    {
        // set each robot and object to the position recorded for that frame
        // mWorld->getRobot(mRobotId)->setQuickDofs( *it );
        // mWorld->getRobot(mRobotId)->update();
        // and record that world configuration
        frame->AddWorld( mWorld );
    }
}

////////////////////////////////////////////////////////////////
// grip selector state change
////////////////////////////////////////////////////////////////

/**
 * @function GRIPStateChange
 * @brief This function is called when an object is selected in the Tree View or other
 *        global changes to the RST world. Use this to capture events from outside the tab.
 */
void DynamicSimulationTab::GRIPStateChange() {
    if ( selectedTreeNode == NULL ) {
        return;
    }
  
    std::string statusBuf;
    std::string buf, buf2;
  
    switch (selectedTreeNode->dType) {
    
    case Return_Type_Object:
        mSelectedObject = (robotics::Object*) ( selectedTreeNode->data );
        statusBuf = " Selected Object: " + mSelectedObject->getName();
        buf = "You clicked on object: " + mSelectedObject->getName();
    
        // Enter action for object select events here:
    
        break;
    case Return_Type_Robot:
        mSelectedRobot = (robotics::Robot*) ( selectedTreeNode->data );
        statusBuf = " Selected Robot: " + mSelectedRobot->getName();
        buf = " You clicked on robot: " + mSelectedRobot->getName();
    
        // Enter action for Robot select events here:
    
        break;
    case Return_Type_Node:
        mSelectedNode = (dynamics::BodyNodeDynamics*) ( selectedTreeNode->data );
        statusBuf = " Selected Body Node: " + string(mSelectedNode->getName()) + " of Robot: "
            + ( (robotics::Robot*) mSelectedNode->getSkel() )->getName();
        buf = " Node: " + std::string(mSelectedNode->getName()) + " of Robot: " + ( (robotics::Robot*) mSelectedNode->getSkel() )->getName();
    
        // Enter action for link select events here:
    
        break;
    default:
        fprintf(stderr, "--( :D ) Someone else's problem!\n");
        assert(0);
        exit(1);
    }
  
    //cout << buf << endl;
    frame->SetStatusText(wxString(statusBuf.c_str(), wxConvUTF8));
    sizerFull->Layout();
}
